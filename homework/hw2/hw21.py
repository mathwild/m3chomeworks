"""Homework 2, part 1
"""

"""Name and CID"""
Output = ["Mathilde Duverger","00978498"]
print "M3C 2016 Homework 2 by", Output[0]
print "CID:", Output[1]

import numpy as np
import matplotlib.pyplot as plt
from scipy import misc
    
def crop(F,T=0,B=0,L=0,R=0):
    """ Crop image represented by matrix F. T,B,L,R indicate 
    how much of the image should be removed from the top, bottom,
    left, and right of the original image.
    """
    """check our initial assertions to be able to run the code"""
    assert 0<=T<1, "error, cropping parameters T should be between 0 and 1"
    assert 0<=B<1, "error, cropping parameters B should be between 0 and 1"
    assert 0<=L<1, "error, cropping parameters L should be between 0 and 1"
    assert 0<=R<1, "error, cropping parameters R should be between 0 and 1"
    assert T+B<1, "error, cropping parameters T and B should add up to one maximum"
    assert L+R<1, "error, cropping parameters L and R should add up to one maximum"
    """get shape of our image"""
    S = np.shape(F)
    """"calculate the number of pixels to be removed"""
    FT = np.floor(T*S[0])
    FB = np.floor(B*S[0])
    FL = np.floor(L*S[1])
    FR = np.floor(R*S[1])
    """assign new matrix output as cropped version"""
    M = F[FT:S[0]-FB,FL:S[1]-FR,:]
    """normalise matrix M"""
    M = M/ np.amax(M)
    return M  
        
def smooth(F):
    """ Apply a simple smoothing procedure to image matrix
    """
    """split the image in the three colour sub-matrices"""
    FR = F[:,:,0] 
    FG = F[:,:,1] 
    FB = F[:,:,2]
    S = np.shape(F)
    """initialise smoothed colour sub-matrices"""
    MR = np.zeros((S[0],S[1]))
    MG = np.zeros((S[0],S[1]))
    MB = np.zeros((S[0],S[1]))
    """assign the elements of the smoothed matrix as the average of input matrix"""
    for i in range(1,S[0]-1):
        for j in range(1,S[1]-1):
            MR[i,j] = np.sum(FR[i-1:i+2,j-1:j+2])/9.0
            MG[i,j] = np.sum((FG[i-1:i+2,j-1:j+2]))/9.0
            MB[i,j] = np.sum((FB[i-1:i+2,j-1:j+2]))/9.0
    for j in range(1,S[1]-1):
        i = 0
        MR[i,j] = np.sum(FR[i:i+2,j-1:j+2])/6.0
        MG[i,j] = np.sum(FG[i:i+2,j-1:j+2])/6.0
        MB[i,j] = np.sum(FB[i:i+2,j-1:j+2])/6.0
    for j in range(1,S[1]-1):
        i = S[0]-1
        MR[i,j] = np.sum(FR[i-1:i+1,j-1:j+2])/6.0
        MG[i,j] = np.sum(FG[i-1:i+1,j-1:j+2])/6.0
        MB[i,j] = np.sum(FB[i-1:i+1,j-1:j+2])/6.0   
    for i in range(1,S[0]-1):
        j = 0
        MR[i,j] = np.sum(FR[i-1:i+2,j:j+2])/6.0
        MG[i,j] = np.sum(FG[i-1:i+2,j:j+2])/6.0
        MB[i,j] = np.sum(FB[i-1:i+2,j:j+2])/6.0  
    for i in range(1,S[0]-1):
        j = S[1]-1
        MR[i,j] = np.sum(FR[i-1:i+2,j-1:j+1])/6.0
        MG[i,j] = np.sum(FG[i-1:i+2,j-1:j+1])/6.0
        MB[i,j] = np.sum(FB[i-1:i+2,j-1:j+1])/6.0 
    MR[0,0] = np.sum(FR[0:2,0:2])/4.0
    MG[0,0] = np.sum(FG[0:2,0:2])/4.0
    MB[0,0] = np.sum(FB[0:2,0:2])/4.0
    MR[S[0]-1,0] = np.sum(FR[S[0]-2:S[0],0:2])/4.0
    MG[S[0]-1,0] = np.sum(FG[S[0]-2:S[0],0:2])/4.0
    MB[S[0]-1,0] = np.sum(FB[S[0]-2:S[0],0:2])/4.0  
    MR[0,S[1]-1] = np.sum(FR[0:2,S[1]-2:S[1]])/4.0
    MG[0,S[1]-1] = np.sum(FG[0:2,S[1]-2:S[1]])/4.0
    MB[0,S[1]-1] = np.sum(FB[0:2,S[1]-2:S[1]])/4.0  
    MR[S[0]-1,S[1]-1] = np.sum(FR[S[0]-2:S[0],S[1]-2:S[1]])/4.0
    MG[S[0]-1,S[1]-1] = np.sum(FG[S[0]-2:S[0],S[1]-2:S[1]])/4.0
    MB[S[0]-1,S[1]-1] = np.sum(FB[S[0]-2:S[0],S[1]-2:S[1]])/4.0  
    """initialise 3-colour smoothed matrix"""
    MS = np.zeros((S[0],S[1],3))  
    """assign the 3 dimensions to their respective colours"""
    MS[:,:,0] = MR
    MS[:,:,1] = MG
    MS[:,:,2] = MB 
    """normalise our matrix"""
    MS= MS/ np.amax(MS)
    return MS
            
def compress(F2d,C):
    """ Construct a compression of 2-d image matrix F2d which
    requires C times the memory needed for F2d
    """
    assert 0<C<1, "error, C should be between 0 and 1"
    S = np.shape(F2d)
    """This MF is the memory size of the current image F2d"""
    MF = S[0]*S[1]
    U, s, V = np.linalg.svd(F2d)
    """We find k the size of the vector P by firstly calculating 
    the expected memory size of our return MSVD=C*MF. We add the 
    information we have about our U,P and V sizes: U will be M*k, P 
    will be k*1 and V will be k*N. Finally we put all that information
    together and solve for k"""
    k = int(C*MF/(S[0]+S[1]+1))
    P = s[0:k]
    U = U[:,0:k]
    V = V[0:k,:]
    return U,P,V
    
def extract(a1,a2,a3,flag_display=False): 
    """ Reconstruct an approximate 2-d image matrix from the "compressed" variables
    generated by compress
    """
    M = np.dot(np.dot(a1,np.diag(a2)),a3)
    if (flag_display==True):
        plt.figure()
        plt.imshow(M)
        plt.title('Mathilde Duverger extract')
    return M
    

if __name__ == '__main__':
    #Read and display image
    M = misc.imread("image.jpg")
    plt.figure()
    plt.imshow(M)
    plt.show()

   
# The code below can be used to test if
# the code is functioning in a "reasonable" manner.

#    T,B,L,R = 0.1,0.2,0.3,0.4
#    G = crop(F,T,B,L,R)
#    plt.figure()
#    plt.imshow(G)
    
#    G = smooth(M)
#    plt.figure()
#    plt.imshow(G)
#    plt.show()
    
#    a1,a2,a3 = compress(M.mean(2),0.1)
#    G = extract(a1,a2,a3)
#    plt.figure()
#    plt.imshow(G,'gray')
